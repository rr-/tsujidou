#!/usr/bin/env python3
import pickle
import threading
import concurrent.futures
from pathlib import Path
from typing import List, Dict, Tuple
from lib import engine, util
from lib.tlg import tlg
from lib.snapshot import SnapshotEntry
from lib.open_ext import open_ext, ExtendedHandle
import configargparse


_lock = threading.Lock()


class Transformer:
    def get_file_name(self, index: int, entry: engine.FileEntry) -> str:
        if entry.is_extractable:
            assert entry.file_name is not None

            if entry.file_name.endswith('.tlg'):
                return entry.file_name + '.png'

            return entry.file_name
        return '{:05d}_{:016x}.dat'.format(index, entry.file_name_hash)

    def transform_content(
            self, entry: engine.FileEntry, content: bytes) -> bytes:
        if entry.file_name is not None and entry.file_name.endswith('.tlg'):
            assert tlg.is_tlg(content)
            return tlg.tlg_to_png(content)

        return content


class ScriptTransformer(Transformer):
    def get_file_name(self, index: int, entry: engine.FileEntry) -> str:
        return '{:05d}_{:016x}.dat'.format(index, entry.file_name_hash)

    def transform_content(
            self, entry: engine.FileEntry, content: bytes) -> bytes:
        return content.decode('cp932').encode('utf-8')


def unpack_entry(
        handle: ExtendedHandle,
        entry: engine.FileEntry,
        target_path: Path,
        transformer: Transformer) -> None:
    if target_path.exists():
        print('Ignoring existing file {:016x} -> {}'.format(
            entry.file_name_hash, target_path))
        return

    if not entry.is_extractable:
        print('Ignoring unextractable file {:016x}'.format(
            entry.file_name_hash))
        return

    print('Unpacking file {:016x} -> {}'.format(
        entry.file_name_hash, target_path))
    try:
        with _lock:  # reading from the shared file handle needs to be atomic
            content = engine.read_file_content(handle, entry)
        content = transformer.transform_content(entry, content)
        util.save_file(target_path, content)
    except Exception as ex:
        print('Error unpacking {:016x}: {}'.format(entry.file_name_hash, ex))


def unpack(
        source_path: Path,
        target_dir: Path,
        file_name_hash_map: Dict[int, str],
        transformer: Transformer) -> List[SnapshotEntry]:
    with open_ext(source_path, 'rb') as handle:
        table = engine.read_file_table(handle, file_name_hash_map)

        def work(args: Tuple[int, engine.FileEntry]) -> SnapshotEntry:
            entry_num: int = args[0]
            entry: engine.FileEntry = args[1]
            relative_path = Path(transformer.get_file_name(entry_num, entry))
            target_path = target_dir.joinpath(relative_path)
            unpack_entry(handle, entry, target_path, transformer)

            return SnapshotEntry(
                entry.file_type,
                entry.file_name,
                entry.file_name_hash,
                relative_path,
                target_path.stat() if target_path.exists() else None)

        with concurrent.futures.ThreadPoolExecutor(max_workers=8) as executor:
            return list(executor.map(work, enumerate(table.entries)))


def parse_args() -> configargparse.Namespace:
    parser = configargparse.ArgumentParser(
        default_config_files=['./config.ini'])
    parser.add('--game-dir', required=True)
    parser.add('--data-dir', required=True, default='./data')
    parser.add(
        '--file-names', default='file-names.lst',
        help='used for extracting non-scripts')
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    game_dir = Path(args.game_dir)
    data_dir = Path(args.data_dir)
    file_name_hash_map: Dict[int, str] = {}

    if args.file_names:
        file_name_hash_map = {
            engine.get_file_name_hash(line.strip()): line.strip()
            for line in Path(args.file_names).open('r', encoding='utf-8')
        }

    directories: Dict[str, Tuple[str, Transformer]] = {
        'script.dat': ('script', ScriptTransformer()),
        'arc0.dat': ('arc0', Transformer()),
        'arc1.dat': ('arc1', Transformer()),
        'arc2.dat': ('arc2', Transformer()),
    }

    for source_name, (target_name, transformer) in directories.items():
        source_path = game_dir.joinpath(source_name)
        target_dir = data_dir.joinpath(target_name)

        print('Unpacking directory {} -> {}'.format(source_path, target_dir))
        snapshots = unpack(
            source_path, target_dir, file_name_hash_map, transformer)

        snapshot_path = data_dir.joinpath(target_name + '-snapshot.dat')
        with snapshot_path.open('wb') as handle:
            pickle.dump(snapshots, handle)


if __name__ == '__main__':
    main()
